\section{Лекция 5}
\subsection{Совместное использование прерываний}
Когда писали свое F1 прерывание, то мы не беспокоились о том, что его кто-то будет использовать. Прерывания int 1, int 3 - должны были восстановить. Вспомнили, что в TD у нас не получалось пройтись и посмотреть, как ведет себя код, в котором мы перехватывали прерывания.

\subsection{int 16}
Смотрим, что 16-е прерывание у Norton Guide. Если будет 16 прерывание, то прерывание перехватит NG. NG передаст сервис DOS, DOS передаст BIOS, а потом обратно по цепочке.

\begin{hw} DOS/MU/kc 16. Нужно копировать воспроизвести ks в режимах 16 int и  9 int. Cntl + M - "нотка"(13-й) - внимательно обрабатывать. Связь кода и картинки\end{hw} 
Печатать на экран, что возвращаетz BIOS, (2 возвращенных кода и картинку).

\begin{rem}Садимся на 16-й int. Мы не знаем, сколько обработчиков под нами.\end{rem}
DOS перехватил 16-й int, направил на себя, потом DOS переправляет по старому адресу. Описываем распространение сигнала. 

Вверху сидит BIOS. Изначально 16-й вектор, который сидит в 16-й ячейки памяти, лежит указание на BIOS. После загрузки DOS менят 16-й int на себя. Теперь управление приходит в DOS, а DOS не имея другой информации,  передает управление в BIOS. "DOS сел сверху и передает управление по старому адресу". Потом "сверху сел" NG. NG "отдается" DOS. NG не знает ничего про BIOS. BIOS вернул DOS'у информацию, DOS протранслировал это. NG просыпается, но нам "наверх", когда зовем int 16, то управление идет к нам, но NG уже подменил (Shift + F1 не печататется). Сняли NG - все печатается.  

Схема совместного использования.
Есть утилита "interrupt counter" считает кол-во вызовов 16 int.  Его нужно отдать обязательно.

Work => symdeb -a (ассемблирование). ENTER выход их режима. -u режим дизасемблирования. Заметим, что вывод в littel endian. Байты в обратном порядке - соглашение о размещении многобайтных величин.

Посмотрим, что в ячейке, до того, как поменяем. В одном парагрфе 4 вектора, нужно пройти 5 полных параграфа и ещё 2 вектора. Посмотрели что в памяти, место где TSR. Конкретно смотрим pepores'ом. Забрали оттуда 25 AF 6A FA. К этим ячейкам памяти обращается сам процессор. 

Запишем туда своё значение. Запустили код, 16-й int указывает на нас. Мы сели сверху. Смотрим ячейку. В TSR 3DA1 - это наш код. Смотрим 3DA1 - наш код, где в нашей программе мы ссылаемся на старые коды, которые мы сохранили.

iret возвращает старый флаги, который были у пользователя до вызова. Информация во флагах возвращается. 

\begin{rem}
Когда на клавиатуре нажимается кнопка, то срабатывает аппартное прерывание, возможно, даже останавливается текущая программа, и срабатывает обработчик аппаратного прерывания. 
\end{rem}

Процессор вызвал обработчик прерывания 9. Программа не заметила, что её прерывали и обслуживали клавиатуру. Для программы это невидимо, и она не знает, что что-то нажато. Программа узнает это через int 16.

400h - область данных BIOS. Буффер клавиатуры. Можем посмотреть, что там все меняется.  

Assembly => Low Memory Usage

9 int складывает все в буффер, а 16 int забирает данные из буффера. 
16 программное прерывание, это по нашему требованию. Pepores просывается по 9 прерыванию.
При alt alt alt ничего в буффер не кладем.

\begin{off}Можно приступать к реалзации int16.\end{off}
~\\
Способы организации
\begin{enumerate}
\item Синхронная организация (int 16)
\item Асинхронная организация (int 9)
\end{enumerate}
Поллинг - прием постоянного опроса.

Как решается вопрос в \bfseries синхронной\mdseries схеме?
Есть вычислительная задача. Но мы хотим работать с клавиатурой. Нужно модуль решающей проблемы с клавиатурой научить работать квантами. Далее необходимо организовать цикл в котором будем считать и опрашивать клавиатуру. 

Как сделать это умно? Чтобы не делать лишних действий. Затраты вычислительного времени хотелось бы минимизровать.

Как это решается в \bfseries асинхронной\mdseries схеме? Вспоминаем многопочточное программирование. Пусть у нас есть модель Т. Мы его считаем, но сначала написали перед ним KBD обработчик, и если получили int 9, анализирую вход  можем приостановить вычислительный процесс.

В синхронном режиме все выполняется в ритме процессора, а в асинхронной схеме обработка постувших сигналов из "другого мира" не зависим от ритма процессора. Другая временная логика. 

В одном процессе формируются два thread'а: один под вычисления, один под опрос. Если поток во втором thread фиксирует нажачие, то идет "kill" на вычислительный модуль. Плюс в том, что не нужно менять код вычислительного модуля. Минус в том, что мы все равно делаем много лишних опросов. Традиционно такое решение относят к асинхронному режиму. 

При обработке 9-го прерывания мы будем строить асинхронную схему, что при решении будущих задач вряд ли встретися в чистом виде. 

\begin{off} USB - поллинговоре решение \end{off}

\subsection{Int 9}
Для части 2 необходимо 9-й вектор взять без DOS. Там есть проблема, которая покажет понимание идеи о том, что прерывание просходит в любой момент. Это значит, что нужно все сохранять и восстанавливать (включая флаги).  DOS это int 21h, активен, только тогда, когда мы его зовет. Как его звать, ведь у нас однозадачная система? Как позвать второй раз DOS? В любой момент может быть прерывание, если в обработчике снова будет вызван DOS, то DOS рухнет. Когда стек переполнится, то он может случайно что-то затиреть. Побоялись переполнение, меняют нам стек.

Есть DOS, где-то в памяти - стек. DOS боится его переполнить. DOS берет ss, sp складывает их в ячейку памяти. SS устанавливают в свой системный стек (ss = x1, sp = y1) в ss, sp - новые значения. Когда DOS отработал, то из глобальной ячейки достаются оригиналы ss и sp, возвращая наш стек.

При втором вызове мы затираем глобальную ячейку. Второй вызов обслуживается хорошо, но когда возвращаемся на первый вызов - то нам уже не восстановить затертые ss и sp.

Ячеек глобыльных несколько. Поэтому можем звать на разрешенных участках можем звать DOS второй раз. Генерируется Int 28 - когда позволено вызвать DOS второй раз, можем его перехватить и второй раз вызвать DOS. NG перехватывает 16 и 28. В результате, он по 16 int ставит флаг, что было бы хорошо проснуться. NG просыпается по 28 int.  

int 28 очень много, поэтому для нас ожидани очередного int - незаметно. 


\subsection{Работы процессора}
Сверху выборка, декодирование, снизу - выполение. Процессор получаетс байт EAh, понимает, что нужно выбрать ещё 4 байт, если CD то выбрать ещё 1 байт. 

На этапе выполнения могут возникать exceptinon (деление на 0), на этапе декодирования могут возникать exception (undefined).

В области межну завершнием выполнения одной инструкции и началом декодирования другой может прооизойти внешние прерывание.

Выполнение одной инструкции
\begin{enumerate}
\item Out of order execution. Сюда включается компиляция в микрокод. Все, что послыем процессору компилируется в микрокод и выполняется в том порядке, который ОНИ определили. 
\item Суперскалярность. Несколько конвейров для выполнения микроинструкций. Наприме, адресный конвейр. В процессоре есть специальный модуль сборки, который собирает результат. Уже на уровне процессора поддерживается виртуализация. 
\item Спекулятивность. Выборка делается далеко заранее. Как вариант,из двух ветвлений выбирает одну ветку и по ней делает предвыборку. Или если будет статистика, то делаем так, как делали раньше. Все статистические данные хранятся в процессоре. Можно hint-ом подсказать, но не факт, что это даст прирост производительности. 
\end{enumerate} 

Одна ножка, за которую процессор "дергают" внешние устройства.  По дороге стоит контроллер(8 входом, 1 выход) - контроллер прерываний. IRQ - номера входов. Проекция IRQ на int: c 08h по Fh,
71h по 77h. На второй выход IRQ контроллера навесили каскадно ещё одни контроллер. У обоих контроллерах на 0 входах подключены часы. 

Часы у первого контроллера = 18.2 Гц, системный таймер. Часы у второго контроллера = 1024 Гц, RTC (Real Time Clock). На RTC работает современная многозадачность. 

\begin{rem}
Кен Олсон - создатель компании DEC. Предсказал много направление в области современных технологий. Дэйв Кутлер - создатель Windows NT. Билл Гейтс предсказывал эру мобильных вычислительных устройст, связанных в одну сеть.\end{rem}

Контролееры назывались PIC - Programming Interrapt Controller. Сейчас APIC на 24 входа.

\begin{hw}Прочитать к следующему разу: LU/io(alt + F4) ; третий пункт, программируемый контроллер прерываний(21 страница); картики в таймере на int8\end{hw}

В следующий раз обсуждаем, что происходит, когда сигнал от клавиатуры доходит до процессора. NMI - посмотреть.
