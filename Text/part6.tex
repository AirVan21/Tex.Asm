\section{Лекция 6}
\begin{hw} Вопрос, почему после int 21h, не протрассировался ret. Такое проскакивание происходит и в начале.\end{hw}
Причина, почему сделали однобайтную инструкцию CC, а не int 3 (СD 03) - мы, захватывая 2 байта, затираем другой байт. На этот байт мог быть jmp. А в случае однобайтной инструкции CC мы избегаем данной проблемы. Если в том байте - точка входа, то затирая что-то мы портим точку входа. 

\subsection{Обработка аппаратных прерываний}
Восстанавливаем картинку с ножкой процессора, общающейся с программируемым контроллером прерываний(ПКП).  

Как проходит сигнал. Произошло дейтсвие на клавиатуре. На клавиатуре есть чип, он обрабатывает то, какая клавиша была нажата. Кладет код в буффер чипа клавиатуры. Чип клавиатуры меняет напряжение на проводе, связывающем его и контроллер. Чип клавиатура дергает ПКП. Учитывая приоритет, выставленный на ПКП, дергаем процессор за ногу. Процессор доходит до момента, когда может происходить "внешнее прерывание". Процессор знает, что его дергают за ногу для внешних устройств. CLI(Interrupt Flag = 0) - не реагируем на прерывания, STI(Interrupt Flag = 1) - обрабатываем прерывание. Если IF = 1, то процессор не выполняет инструкцию по CS::IP, а начинает заниматься прерыванием. Во-первых, мы должны были сделать все невидимым. Должны сохранить регистры (кладем с stack): регистр флагов (который потом будет меняться, например, IF), CS, IP (чтобы потом вернуться). Это все складывается на stack сразу. 

Далее процессору нужно узнать, какой брать вектор. Для этого он посылает запрос контроллеру, желая узнать номер контроллера.

Абстракция \bfseries in, out\mdseries. Это все, что связывет процессор с внешним миром. Все проходит через 2 эти инструкции. Адресация - пространство памяти(RAM в любой момент к любой ячейке памяти). У процессора 2 адресных пространства: mem, IO. IO - пространство входа-выхода, где 16 bit на адрес. Каждый байт в IO - это порт. 

\begin{rem} Посмотреть, что такое "грязная дюжина" IBM. Элитная команда. Разрабатывали ISA шину\end{rem}

Процессор, обращаясь в IO broadcast'ом шлет адрес. Устройства знают, какие порты его. Устройство, приписанное к порту - понимает это. Процессор запрашивает с этого адреса in или дает на запись out.  

Процессор узнает у контроллера IRQ. Информация для mapping'a отражения IRQ на int хардкодом прошита в процессор, выполняется процессором. 

Процессор вычисляет адрес вектора, достает CS::IP и передает управление. 

\begin{rem} Как контроллер узнает, что процессор начал обрабатывать прерывание? Процессор сообщает ПКП, что начал им заниматься. ПКП теперь ждет и не "дергает" процессор.\end{rem} 

Мы и процессор: действий в секунду(10, $10^{9}$), квант времени ($10^{5}$ $\approx$ сутки, $10{-3}$).

\begin{rem} Зачем при входе в обработчик сбрасывается IF, IF(0)\end{rem} 

\begin{off} Юрий Нестеренко. "Дай бог памяти". "Что было бы если программисты строили дома". "Проект генезис".\end{off}

Диаграмма(цикла обработки команды) - выборка из памяти и декодирование, выполнение. Промежуток, когда может произойти внешнее прерывание. 

Порядок букв. Нужно учитывать это. 

Вектор, это 4 байта. Значит можем смотреть в pepores. Не забыть перевернуть все. 
\begin{hw} Вектор нужно перехватить вручную\end{hw}

\subsection{Практика}
Как идет работа с клавиатурой. Есть обработчик прерывания 9. Есть обработчик int 16. Есть где-то в памяти KBD buff. Сигнал приходит int 9 вызывается, складывает данные в буффер. int 16 зовется из программы и забирает что-то из буффера. Мы будем ждать некую кнопку, как только обнаружим код нужной кнопки => тогда закроем программу. 

В цикле будем проверять флаг. Если не нажата наша кнопка, то выполняем цикл. Занятое ожидание.  

Адрес порта клавиатура 60h. На 60h отзывается чип в клавиатуре. Карта портов есть у Brown'а. 
in берет байт из буффера клавиатуры. Проектировщики клавиатуры решили, что мы сохраняем один байт по нажатию клавиатуры. 

Код нажатия и код отпуская - 2 разных сигнала.

Может быть неизвестное значение регистра ds. Когда наш код проснется - предугадать невозможно. Сигнал, по сути, из другого времени. Асинхронный стиль. Поэтому можем писать cs::f9.
ds по default поэтому мы его модифицировали. Можно всегда писать префиксы и быть уверенными во всем. 

Когда мы обрабатывали только esc, то то, что сложилось в буффер и не считывалось 16 int потом считалось NC (который направил int 16). 

Печатать DOS'м нельзя. 21 int в аппаратном обработчике - плохо, точно. 

Если вызвать кого-нибудь, кто ещё работал с DOS, то смогли повесить DOS. Нужно провести эксперимент, чтобы повесить DOS.

int 10 - вывод на экран. Печатать можно BIOS'м. 

\begin{hw}Нужно сделать нормальное решение - 10 int'ом печатать в колонку. Функция 6 или 7\end{hw}

\begin{off}Как только появляется интерфейс, то программирование резко усложняется. DirectX - библиотека, её сделали по заказу Microsoft. Все геймерные производители перешли на DirectX.  
\end{off}

Нужно напечатать символ и сдвинуть курсор. Перед этим считать позицию курсора. Посмотреть NG.
Что нужно будет. Нам нельзя будет отдавться старому обработчику.

Попробовать добиться того, чтобы коды приходилив обратном порядке. Обработчик должен быть прерван следующим сигналом. Должны сделать sti. По одной клавише 2 кода. Серые кнопки, начинающиеся с E0.     
sti нужно ставить сразу. 

Распространение сигнала по железу, а потом распространение по обработчику. 
 
Программируемый периферийный интерфейс - тут смотреть порт 60. 
