\section{Лекция 2}
\subsection{Прерывание.Таймер}
Все началось с того, что определить версию процессора Intel не такая уж и простая задача. Но с появление команда \bfseries cpuid \mdseries проблема решилась. 
Но в процессорах до Pentium этой функции не было, поэтому приходилось что-то придумывать. 

Поступил вопрос: "Как посмотреть, где находится программа во время выполнения?". Как попсмотреть это место, не делая её программой резидентом? Из всех предложеложенных вариантов больше всего подошел вариант с breakpoint'ами. Но посчитали, что вставив в код прерывание сделаем лучше.

xor ax, ax;

int 16h   ; прерывание bios по обслуживанию клавиатуры

~\\

Вообще прерывание бывают(это не полный список, как я понял):
\begin{enumerate}
\item Программные
\item Внутренние
\item Аппаратные 
\end{enumerate}
Заметим, что аппаратные прерывания зависят от таймера. Таймер зависит от системного времени. 
Тест был в том, что мы написали hlt (тем самым остановив процессор), но так как аппаратный таймер производит отсчет 18.2 раза в секунду, то он практически сразу же "завел" процессор. 

Вообще есть Real Time Clock который обеспечивает переключение процессов в многозадачных системах, причем там таймер делает отсчет 1024 раза в секунду. Поэтому квант процессорновго времени приблизительно равени 1 милисекунде.

\subsection{Управление.Отладчик}
Передать управление, есть не что иное, как перейти к исполнению другой команды. Помним, что за это отвечает регистр IP = Instruction Pointer. В чем идея? Когда одна подпрограмма вызывает другую, то адрес возврата помещается в stack, причем когда вызываемая программа завершает работу, то она ret'ом загружает из stack'a в IP адрес вызывающей подпрограммы.

Отметим, что int param; - где param по сути означает семещение, которое мы отсупаем, чтобы попасть на нужную библиотечную функцию. По этому адресу как раз и передается управление.

Заметим, что когда вызываем tsr, то там вложенно все вызывается. nc => command.com => tsr. Но tsr знает, что после того, как он отработает, он вернет управление и закончит работу, поэтому в памяти он себя не прописывает. Command.com на самом деле тоже возвращает управление (т.е. меняет регистр IP), но он все ещё отображается, поэтому это искажет наше предстваление. 

\begin{rem} Передать управлениие - делать переход на область памяти\end{rem}
\begin{hw} int x => CD | X (такое представление). Намек на то, что алфафит OPCODE'ов переполнен. Почему для breakpoint'a int 3 выделили отдельный байтовый опкод CC?\end{hw}

\begin{rem} Если мы видим, что первый байт, в 2-х байтной связке для OPCODE равен OF, то это нам говорит о том, что мы должны смотреть в другой таблице команд.\end{rem}

ОС всегда завершает программы, поэтому мы можем увидеть в начале нашей программы символы
\bfseries CD 20\mdseries , что говорить нам о том, что вызывалось прерывание int 20h (прервать программу = terminate programme).

Ещё раз вспоминаем, что ret восстанавливает в IP адрес из stack.

Посмотрели в памяти, что отступ, который мы прописывал \slshape orh 100h\upshape , использовался для размещения параметров. Заметим, что это смещение учитывалось, когда мы писали offset m1. 

Интересная вещь, то то, что  мы объявляли строку, как набор 1-байтных элементов, поэтому и писали "db" (data byte). Чтобы взять не 1 символ, а 2, например, нужно будет указать "word ptr m1", где word подразумевает 2 байта.    
