;вначале читаем http://www.ht-group.net/1022/ (это для 32-35 строк) В принципе после этого станет понятно что мы тут творим.
		model	tiny
		.486    ; Разрешает ассемблирование непривилегированных инструкций процессора i486. 
		.code   ; Мы писали .486, поскольку бесило, что для обеспечения совместимости со всем асм по факту переводил команды shr al,4 переводил в 4 команды shr al,1 А с этой директивой он уже реально делает shr al,4
		org	100h
_:		jmp	start

m1		db	'    $'

start:		push 	cs ; запоминаем значение cs в ax (mov'ом нельзя из cs в ax перенести)
		pop	ax
		push	cs
		pop	es
		mov	di,offset m1 ;это нам будет нужно для stosb
		cld	    ;Сброс флага направления (Калашников стр 235), не понимаю зачем здесь это. Если кто знает, то напишите)
		call	h4

		mov	dx,offset m1
		mov	ah,9
		int	21h
		ret

h4:		push	ax
		mov	al,ah ;переносим верхнюю пару тетрад в нижнюю 
		call	h2
		pop	ax
h2:		push	ax
		shr	al,4 ;необходимо для распечатывания первой тетрады из пары.
		call	h1
		pop	ax
h1:		push	ax
		and	al,0Fh ;обнуляем 1 тетраду из пары, ибо это важно (читаем статью)
		cmp	al,10 ;сравнимаем с A (читаем статью)
		sbb	al,69h ;Вот это уже расчеты от элиты. После SBB числа 0-9 превращаются в 96h - 9Fh, а числа 0Ah - 0Fh - в 0A1h -0A6H. Затем DAS вычитает 66h из первой группы чисел, переводя их в 30h - 39h, и 60h из второй группы чисел, переводя их в 41h - 46h
		das ;короче 34-35 строки очень заумно повторяют то, что написано в статье. (там этот способ тоже есть, но он не объясняется)
		stosb ;вместо строки из пробелов посимвольно будем записывать то, что нам нужно. (читаем, что делает stosb)
		pop	ax		
		ret
		end	_
