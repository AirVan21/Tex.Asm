;Для того чтобы хотя бы примерно понять что тут происходит, надо прочесть /LU/io.doc, 4 глава "Таймер и генерация звука".
;Также будет полезно прочесть Разговор о 10.txt
		model	tiny
		.code
		org	100h
_:		jmp	start

m0		db	'Begin',13,10,'$'
m1		db	'End',13,10,'$'

start:		mov	dx,offset m0
		mov	ah,9
		int	21h

		mov	al,0B4h ;0B4h - управляющее слово 10110100 - двоичный код; режим 2(генератор частоты); младший байт, затем старший(вид загрузки счетчика); канал 2
		out	43h,al  ;запись управляющего слова в регистр режима канала
		mov	dx,12h
		mov	ax,34DDh ;теперь (dx,ax) = 1234DDh = 1193181 = тактовая частота таймера в Гц (то есть 1193181 тиков в секунду)
		mov	cx,100 ;требуемая частота (звука). ПС мы тут вообще то со звуком работаем %) 
		;Эта частота кстати не должна быть меньше 18Гц, иначе произойдет переполнение (это из аппаратных соображений). 
		div	cx ;ax=(dx,ax)/cx по данной формуле вычисляется значение счетчика 2-го канала. (Это такой факт из io.doc)
		out	42h,al ;загрузка счетчика канала 2 (загружаем вначале младший байт)
		mov	al,ah  ; теперь в al старший байт
		out	42h,al ;загрузка счетчика канала 2 (теперь загружаем старжий байт)
		;теперь счетчик будет уменьшатся с 1193181/100 до нуля и снова по кругу. А частота его декрементов = 1193181 Гц.

		mov	cx,1000 ; cx будет счетчиком цикла
_c0:		push	cx	; можно не делать push cx (мы его не трогаем)
		mov	bx,-1

_c1:		mov	al,80h ;теперь пишем управляющее слово 80h = 10000000 = двоичный код; режим 0(прерывание терминального счета), защелкивание (биты 0-3 безразличны), канал 2
		; "Существует два способа чтения текущего значения счетчика канала.
		;  1. Чтение с остановом счетчика (нам не нужен)
		;  2. Чтение "на лету" Для считывания счетчика без остановки процесса счета используется посылка в порт 43h управляющего слова в режиме "защелкивания". Это управляющее слово фиксирует текущее значение счетчика и Вы можете считать его младший байт, а затем старший байт"
		out	43h,al ;запись управляющего слова в регистр режима канала
		in	al,42h ;чтение счетчика канала 2 (читаем младший байт счетчика)
		mov	ah,al  ;запомнили младший байт счетчика в ah 
		in	al,42h ;чтение счетчика канала 2 (читаем старший байт счетчика)
		xchg	ah,al ;меняем значения ah и al местами,так что бы порядок старший байт/младший байт счетчика  был правильным. 

		cmp	bx,ax
		mov	bx,ax
		ja	_c1 ;jmp если bx>ax

		pop	cx ;можно не делать push/pop cx
		loop	_c0 ;dec(cx) и повторяем все снова с отметки _c0

		mov	dx,offset m1
		mov	ah,9
		int	21h
		ret
		end	_
