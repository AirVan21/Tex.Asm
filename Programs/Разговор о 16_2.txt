[22:14:29] Alexey Kor: Здравствуйте! Если можно, то я бы хотел спросить по поводу одной из програм, написанных на парах, а именно 16_2. В ней мы делаем свой обработчик 16 int, в котором вызываем исходный обработчик через call far и после этого возвращаем управление. Я не могу понять как работают с 11 по 25 строчки.
[22:14:34] Alexey Kor: Как я понимаю происходящий процесс:
[22:14:38] Alexey Kor: 0) Наша программа сидит в резидентах.
[22:14:44] Alexey Kor: 1) Откуда-то происходит int 16, то есть pushf, TF=0, IF=0, push CS, push IP.
[22:14:50] Alexey Kor: 2) В нашем обработчике мы делаем pushf (сейчас это те же флаги, что были до вызова int 16, но TF и IF = 0). Потом делаем far call к исходному обработчику, то есть push CS, push IP.
[22:14:56] Alexey Kor: 3) Поскольку сделав far call по факту мы вызвали прерывание, то в конце будет iret, то есть pop IP, pop CS, popf. (и мы вернули старые флаги, где TF и IF = 0, то есть те же, что мы запомнили в шаге 2)
[22:15:02] Alexey Kor: 4) Далее мы заменяем флаги, которые были сохранены в 1 шаге при вызове int 16, на такие же, как в шаге 2. То есть такие же как исходные, но TF и IF = 0
[22:15:09] Alexey Kor: 5) Дальше происходит iret, то есть pop IP, pop CS, popf и мы вернули управление из нашего обработчика. НО теперь у нас не те же флаги что были до вызова int 16, а такие же, но TF и IF = 0.
[22:15:17] Alexey Kor: И несмотря на то, что IF=0, ввод с клавиатуры все равно работает (хотя вроде бы прерывания запрещены).
И вот я не понимаю как это так оно работает?
[22:16:32] Alexey Kor: Извините, что много сообщений отправил, просто если не разделять сообщения, то плучится сплошной текст, который наверное, невозможно было бы разобрать.
[23:16:44] Баклановский Максим: Добрый вечер!
[23:17:34] Баклановский Максим: Прекрасный разбор.
[23:21:02] Баклановский Максим: Почему работает клавиатура? Кто-то вызывает int 16, его обработчик делает sti, IF=1 сохраняется до конца выполнения обработчика.
[23:29:30] Alexey Kor: Да, во время работы оригинального обработчика IF=1, но когда мы из оригинльного обработчика вернемся в наш (то есть после шага 3), то мы вернем старые флаги, а в них IF=0. И когда мы возвращаемся из нашего обработчика (после 5 шага) IF по прежнему остается равен нулю. То есть вызвав один раз int 16 мы сделаем эти пять шагов, оставив в итоге IF = 0 и вроде бы второй раз уже сделать ничего не сможем (насколько я понимаю, все вообще должно зависнуть, так как IF=0 и это никто не исправляет), но по факту все продолжает работать и мы можем сколько угодно раз нажимать клавиши и выхывать int 16 и ничего не зависает.
[23:30:45] Баклановский Максим: Обработчик 16-го инта сделает sti.
[23:33:13] Alexey Kor: а popf в iret обработчика int 16 не изменит IF обратно на ноль? (на шаге 3)
[23:38:56] Баклановский Максим: Конечно, изменит.
[23:39:07] Баклановский Максим: Вот проверка:
[23:39:16] * Баклановский Максим sent file 16_2C.ASM.
[23:40:43] Баклановский Максим: Но за время выполнения обработчика 16-го инта (той его части, которая после sti), 9-е инты успеют сгенерироваться.
[23:50:38] Баклановский Максим: Вы не забыли, что IF=0 запрещает процессору реагировать только на IRQ?
[23:51:03] Баклановский Максим: Команда int 16 будет нормально работать.
[23:59:50] Alexey Kor: Так, а вызывает эти 16 прерывания дос?
Thursday, 3 April 2014
[00:01:43] Баклановский Максим: Кто хочет, тот и вызывает. В 16_2с это делаем мы сами. После посадки резидента 16_2 это делает nc.
[00:03:23] Alexey Kor: Ясно, но если бы никто не вызывал 16 инт, то мы бы ничего не смогли набрать?
[00:07:15] Баклановский Максим: Если бы мы работали с клавиатурой по 9-у инту (т.е. перехватили бы его и из своего обработчика передавали бы информацию в свою же программу) и при этом однажды вызвали бы инт 16 (при наличии резидента 16_2), то да.
[00:08:57] Баклановский Максим: Но даже в этих условиях скорее всего клавиатура обрабатывалась бы.
[00:10:06] Баклановский Максим: Мы же зовём какие-то инты, а их обработчики обычно делают sti.
[00:11:25] Баклановский Максим: Понятно, что делать таких резиденnов, как 16_2, крайне нежелательно.
[00:15:00] Alexey Kor: Понял, спасибо! Но возникает второй вопрос. Почему если мы убираем 4 шаг (то есть не заменяем старые флаги, на такие же флаги но с TF и IF нулями), то дальше уже ничего не вводится с клавиатуры? (Ну то есть, если мы закомментируем 15-23 строчки)
[00:22:30] Баклановский Максим: Обычная последовательность работы с клавиатурой такая:
1. int 16 ah=1
2. Если not ZF (ZF=0), то int 16 ah=0
[00:24:28] Баклановский Максим: Т.е. информация о наличии какой-то информации в буфере клавиатуры передаётся через флаги.
[00:26:37] Баклановский Максим: Это одно из ранних решений. Так удобно только принимать информацию. Передавать из обработчика и корректно передавать по цепочке обработчиков не просто (в чём мы и убедились).
[00:33:32] Баклановский Максим: Не понятно?
[00:34:42] Alexey Kor: Я не очень понимаю как обработчик прерывания может передавать информацию через флаги, если он эту информацию убьем iret'ом?
[00:35:44] Баклановский Максим: Биосовский обработчик складывает её в те флаги, которые восстановятся после команды iret.
[00:35:56] Баклановский Максим: Т.е. через стек.
[00:36:42] Баклановский Максим: Мы же делаем то же самое - через стек.
[00:36:57] Баклановский Максим: Но, как Вы правильно заметили, не вполне корректно.
[00:38:03] Баклановский Максим: ZF передать у нас получается, а IF и TF мы обнуляем.
[00:39:30] Баклановский Максим: Это я про 16_2.
[00:39:46] Alexey Kor: а где после биосовского iret происходит эта смена ZF?
[00:40:38] Баклановский Максим: iret выталкивает флаги из стека, а значение в стеке уже модифицировано.
[00:41:05] Alexey Kor: Осознал! Спасибо большое!
